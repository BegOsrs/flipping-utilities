package com.flippingutilities.ui.utilities;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.util.Map;
import java.util.function.Consumer;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

/**
 * <p>
 * The settings panel is a panel displayed in a modal when a user clicks on the settings button next to the account
 * selector dropdown. Its purpose is to allow modifying various features of the plugin. Perhaps in the future this
 * panel can subsume Runelite's config option for FlippingUtilities as the config option is not as easy to access as this
 * panel.
 * </p>
 * <p>
 * There are primarily two reasons that motivated the need for a settings panel:
 * </p>
 * <ol>
 * <li>
 * The config workflow provided by runelite is good (FlippingConfig), but its static. If we want to change something
 * dynamic that is generated by the user at runtime, the config can't do that. For example, the config can't display
 * all the accounts with a trade history and then give a user an option to delete some, it only contains options
 * written by us at compile time.
 * </li>
 * <li>
 * The config options are not very accessible as they are in a entirely different plugin (the ConfigPlugin)
 * This functionality connot be put into the config structure run
 * </li>
 * </ol>
 * This is broken out into its own class instead of residing in the MasterPanel because it will contain
 * enough distinct functionality from the MasterPanel that adding it in their will muddle the responsibility of the
 * master panel and hurt readability.
 */
public class SettingsPanel extends JPanel
{
	int width;

	JPanel sectionContainer;

	Map<String, JPanel> sections;

	Map<JComponent, Consumer<JComponent>> dynamicComponents;

	public SettingsPanel(int width)
	{

		JPanel sectionPanel = new JPanel(new GridBagLayout());

		setSize(new Dimension(width, 300));
	}


	public void addDynamicOption(String section, JLabel label, JComponent component, Consumer<JComponent> updateComponent)
	{
		if (!sections.containsKey(section))
		{
			return;
		}

		dynamicComponents.put(component, updateComponent);

		JPanel optionPanel = new JPanel(new BorderLayout());
		optionPanel.add(label, BorderLayout.WEST);
		optionPanel.add(component, BorderLayout.CENTER);

		sections.get(section).add(optionPanel, new GridBagConstraints());

	}

	public void refresh()
	{
		SwingUtilities.invokeLater(() -> {
			dynamicComponents.forEach((component, updater) -> updater.accept(component));
			revalidate();
			repaint();
		});
	}

	public void addSection(String name)
	{
		JPanel sectionPanel = new JPanel(new GridBagLayout());
		sections.put(name, sectionPanel);
		sectionContainer.add(sectionPanel, new GridBagConstraints());
	}


}
