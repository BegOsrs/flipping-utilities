package com.flippingutilities.ui.utilities;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Font;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;

/**
 * The setting panel's purpose is to make creating a UI with dynamic options easier, by abstracting all the common
 * logic that most setting UI's would have. I didn't want to couple this with the MasterPanel as it could feasibly be
 * something other components needed, as they might have a need to create a UI for settings they can't fit on their
 * own displays. Perhaps in the future this panel can subsume Runelite's config option for FlippingUtilities as the
 * config option is not easy to access. There are primarily two reasons that motivated the need for a settings panel:
 * <ol>
 * <li>
 * The config workflow provided by runelite is good (FlippingConfig), but its static. If we want to change something
 * dynamic that is generated by the user at runtime, the config can't do that. For example, the config can't display
 * all the accounts with a trade history and then give a user an option to delete some, it only contains options
 * written by us at compile time.
 * </li>
 * <li>
 * The config options are not very accessible as they are in a entirely different plugin (the ConfigPlugin)
 * </li>
 * </ol>
 */
public class SettingsPanel extends JPanel
{

	JPanel sectionContainer = new JPanel();

	Map<String, JPanel> sections = new HashMap<>();

	List<Runnable> componentUpdaters = new ArrayList<>();

	public SettingsPanel(int width, int height)
	{
		setSize(new Dimension(width, height));
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		sectionContainer.setLayout(new BoxLayout(sectionContainer, BoxLayout.Y_AXIS));
		sectionContainer.setBorder(new EmptyBorder(30, 20, 20, 30));
		sectionContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		JScrollPane scrollPane = new JScrollPane(sectionContainer);
		add(scrollPane);
	}

	public void addDynamicOption(String sectionToAddTo, String desc, JComponent component, Runnable updateComponent)
	{
		if (!sections.containsKey(sectionToAddTo))
		{
			return;
		}

		componentUpdaters.add(updateComponent);

		JPanel optionPanel = new JPanel();
		optionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

		JLabel description = new JLabel(desc);
		description.setFont(new Font("Roboto", Font.PLAIN, 12));

		optionPanel.add(description);
		optionPanel.add(component);

		sections.get(sectionToAddTo).add(optionPanel);

	}

	public void rebuild()
	{
		SwingUtilities.invokeLater(() -> {
			componentUpdaters.forEach(Runnable::run);
			revalidate();
			repaint();
		});
	}

	public void addSection(String name)
	{
		JPanel sectionPanel = new JPanel(new BorderLayout());
		sectionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		sectionPanel.setBorder(new EmptyBorder(3, 3, 3, 3));

		JPanel optionsContainer = new JPanel();
		optionsContainer.setLayout(new BoxLayout(optionsContainer, BoxLayout.Y_AXIS));
		optionsContainer.setBorder(new EmptyBorder(10, 0, 0, 10));
		optionsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

		JLabel sectionTitle = new JLabel(name, SwingConstants.CENTER);
		sectionTitle.setFont(new Font("Roboto", Font.BOLD + Font.ITALIC, 18));

		sectionPanel.add(sectionTitle, BorderLayout.NORTH);
		sectionPanel.add(optionsContainer, BorderLayout.CENTER);

		sections.put(name, optionsContainer);
		sectionContainer.add(sectionPanel);
	}
}