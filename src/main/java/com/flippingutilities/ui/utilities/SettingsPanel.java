package com.flippingutilities.ui.utilities;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.nio.ByteOrder;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;

/**
 * <p>
 * The settings panel is a panel displayed in a modal when a user clicks on the settings button next to the account
 * selector dropdown. Its purpose is to allow modifying various features of the plugin. Perhaps in the future this
 * panel can subsume Runelite's config option for FlippingUtilities as the config option is not as easy to access as this
 * panel.
 * </p>
 * <p>
 * There are primarily two reasons that motivated the need for a settings panel:
 * </p>
 * <ol>
 * <li>
 * The config workflow provided by runelite is good (FlippingConfig), but its static. If we want to change something
 * dynamic that is generated by the user at runtime, the config can't do that. For example, the config can't display
 * all the accounts with a trade history and then give a user an option to delete some, it only contains options
 * written by us at compile time.
 * </li>
 * <li>
 * The config options are not very accessible as they are in a entirely different plugin (the ConfigPlugin)
 * This functionality connot be put into the config structure run
 * </li>
 * </ol>
 * This is broken out into its own class instead of residing in the MasterPanel because it will contain
 * enough distinct functionality from the MasterPanel that adding it in their will muddle the responsibility of the
 * master panel and hurt readability.
 */
public class SettingsPanel extends JPanel
{

	JPanel sectionContainer = new JPanel();

	Map<String, JPanel> sections = new HashMap<>();

	Map<JComponent, Runnable> dynamicComponents = new HashMap<>();

	public SettingsPanel(int width, int height)
	{
		setLayout(new BorderLayout());
		sectionContainer.setLayout(new BoxLayout(sectionContainer, BoxLayout.Y_AXIS));
		sectionContainer.setBorder(new EmptyBorder(5,5,5,5));
		JScrollPane scrollPane = new JScrollPane(sectionContainer);
		add(scrollPane);
	}


	public void addDynamicOption(String section, JLabel label, JComponent component, Runnable updateComponent)
	{
		if (!sections.containsKey(section))
		{
			return;
		}

		dynamicComponents.put(component, updateComponent);

		JPanel optionPanel = new JPanel(new BorderLayout());
		optionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		optionPanel.add(label, BorderLayout.WEST);
		optionPanel.add(component, BorderLayout.CENTER);

		sections.get(section).add(optionPanel, new GridBagConstraints());

	}

	public void rebuild()
	{
		SwingUtilities.invokeLater(() -> {
			dynamicComponents.forEach((component, updater) -> updater.run());
			revalidate();
			repaint();
		});
	}

	public void addSection(String name)
	{
		JPanel sectionPanel = new JPanel(new BorderLayout());
		sectionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		sectionPanel.setBorder(new EmptyBorder(3,3,3,3));
		JPanel optionsContainer = new JPanel(new GridBagLayout());
		optionsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		sectionPanel.add(new JLabel(name), BorderLayout.NORTH);
		sectionPanel.add(optionsContainer, BorderLayout.CENTER);

		sections.put(name, optionsContainer);
		sectionContainer.add(sectionPanel, new GridBagConstraints());
	}


}
