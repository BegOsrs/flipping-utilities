package com.flippingutilities.ui;

import com.flippingutilities.FlippingPlugin;
import java.awt.Dimension;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import jogamp.newt.driver.opengl.JoglUtilPNGIcon;
import net.runelite.client.plugins.config.ConfigPlugin;
import net.runelite.client.ui.PluginPanel;

/**
 * <p>
 * The settings panel is a panel displayed in a modal when a user clicks on the settings button next to the account
 * selector dropdown. Its purpose is to allow modifying various features of the plugin. Perhaps in the future this
 * panel can subsume Runelite's config option for FlippingUtilities as the config option is not as easy to access as this
 * panel.
 * </p>
 * <p>
 * There are primarily two reasons that motivated the need for a settings panel:
 * </p>
 * <ol>
 * <li>
 * The config workflow provided by runelite is good (FlippingConfig), but its static. If we want to change something
 * dynamic that is generated by the user at runtime, the config can't do that. For example, the config can't display
 * all the accounts with a trade history and then give a user an option to delete some, it only contains options
 * written by us at compile time.
 * </li>
 * <li>
 * The config options are not very accessible as they are in a entirely different plugin (the ConfigPlugin)
 * This functionality connot be put into the config structure run
 * </li>
 * </ol>
 * This is broken out into its own class instead of residing in the MasterPanel because it will contain
 * enough distinct functionality from the MasterPanel that adding it in their will muddle the responsibility of the
 * master panel and hurt readability.
 */
public class SettingsPanel extends JPanel
{
	int width;

	JPanel sectionContainer;

	Map<String, JPanel> sections;

	Map<JComponent, Consumer<JComponent>> dynamicComponents;

	public SettingsPanel(int width)
	{

		JPanel sectionPanel;

		setSize(new Dimension(width, 300));
	}



	public void addDynamicOption(String section, JLabel label, JComponent component, Consumer<JComponent> updateComponent) {
		if (!sections.containsKey(section)) {
			return;
		}

		sections.get(section).add(component);
		dynamicComponents.put(component, updateComponent);
	}

	public void refresh() {
		dynamicComponents.forEach((component, updater) -> updater.accept(component));
	}

	public void addSection(String name) {
		sections.put(name, new JPanel());
		new JPanel().setVisible();
	}


}
